#!/usr/bin/env node
import fs from "node:fs";
import path from "node:path";
import process from "node:process";

import dotenv from "dotenv";
import { parse } from "yaml";

const rootDir = process.cwd();

dotenv.config({ path: path.join(rootDir, ".env.local") });
dotenv.config({ path: path.join(rootDir, ".env") });

const {
  createProductRest,
  updateProductRest,
  updateVariantRest,
  setProductMetafields,
  replaceProductImages,
  getProductByHandle,
  ensureCollection,
  getStoreDomain,
  getAdminApiVersion,
} = await import("../lib/shopify-admin.mjs");

const APPLY_MODE = process.argv.includes("--apply");

function readProducts() {
  const productsDir = path.join(rootDir, "apps", "store", "data", "products");
  const files = fs.readdirSync(productsDir).filter((file) => file.endsWith(".yaml") || file.endsWith(".yml"));
  return files.map((file) => {
    const slug = file.replace(/\.ya?ml$/i, "");
    const raw = fs.readFileSync(path.join(productsDir, file), "utf8");
    const parsed = parse(raw);
    return { slug, ...parsed };
  });
}

function parsePrice(value) {
  if (!value) return null;
  const cleaned = String(value)
    .replace(/[^0-9.,-]/g, "")
    .replace(/,(?=\d{3}(?:\D|$))/g, "");
  if (cleaned.trim().length === 0) return null;
  const normalized = cleaned.replace(/,/g, "");
  const numeric = Number.parseFloat(normalized);
  if (!Number.isFinite(numeric)) return null;
  return numeric.toFixed(2);
}

function toHtmlParagraphs(value) {
  if (!value) return undefined;
  const paragraphs = String(value)
    .split(/\n\s*\n/)
    .map((segment) => segment.trim())
    .filter(Boolean);
  if (paragraphs.length === 0) {
    return undefined;
  }
  return paragraphs.map((segment) => `<p>${segment}</p>`).join("\n");
}

function deriveStatus(status) {
  if (!status) return "active";
  const normalized = String(status).trim().toLowerCase();
  if (["draft", "coming soon", "planned"].includes(normalized)) {
    return "draft";
  }
  return "active";
}

function dedupe(values) {
  const seen = new Set();
  const result = [];
  for (const rawValue of values) {
    if (!rawValue) continue;
    const trimmed = String(rawValue).trim();
    if (!trimmed) continue;
    if (!seen.has(trimmed)) {
      seen.add(trimmed);
      result.push(trimmed);
    }
  }
  return result;
}

function escapeHtml(value) {
  return String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function listToRichText(items) {
  if (!items || items.length === 0) return null;
  const listItems = items.map((item) => `<li>${escapeHtml(item)}</li>`).join("");
  return `<ul>${listItems}</ul>`;
}

function pricingNoteRichText(note) {
  if (!note) return null;
  return `<p>${escapeHtml(note)}</p>`;
}

function testimonialsToRichText(testimonials) {
  if (!testimonials || testimonials.length === 0) return null;
  return testimonials
    .map((testimonial) => {
      const quote = escapeHtml(testimonial.review ?? "");
      const name = escapeHtml(testimonial.name ?? "Customer");
      return `<blockquote><p>${quote}</p><cite>— ${name}</cite></blockquote>`;
    })
    .join("");
}

function faqsToRichText(faqs) {
  if (!faqs || faqs.length === 0) return null;
  return faqs
    .map((faq) => {
      const question = escapeHtml(faq.question ?? "Question");
      const answer = escapeHtml(faq.answer ?? "");
      return `<details><summary>${question}</summary><p>${answer}</p></details>`;
    })
    .join("");
}

function pruneUndefined(object) {
  return Object.fromEntries(Object.entries(object).filter(([, value]) => value !== undefined && value !== null && value !== ""));
}

function extractNumericId(globalId) {
  if (!globalId) return null;
  const match = /\/(\d+)(?:\?|$)/.exec(globalId);
  return match ? match[1] : null;
}

function mapProductToShopifyPayload(product) {
  const title = product.name ?? product.slug;
  const descriptionHtml =
    toHtmlParagraphs(product.description) ??
    toHtmlParagraphs(product.tagline) ??
    `<p>${product.slug} – generated by sync script.</p>`;

  const price = parsePrice(product?.pricing?.price ?? product?.pricing?.price_value);
  const compareAtPrice = parsePrice(product?.pricing?.original_price);

  const productType = product.platform ?? "Software";
  const shopifyCollections = Array.isArray(product?.shopify_collections)
    ? product.shopify_collections
    : product?.shopify_collections
      ? [product.shopify_collections]
      : [];
  const images = Array.isArray(product?.screenshots)
    ? product.screenshots
    : product?.screenshots
      ? [product.screenshots]
      : [];
  const tags = dedupe([
    product.platform,
    ...(product.categories ?? []),
    ...(product.keywords ?? []),
    ...shopifyCollections,
  ]);

  const featuresRich = listToRichText(featureItems);
  const testimonialsRich = testimonialsToRichText(testimonialItems);
  const faqsRich = faqsToRichText(faqItems);
  const pricingBenefitsRich = listToRichText(pricingBenefitsList);

  const metafields = [
    {
      namespace: "serp",
      key: "slug",
      type: "single_line_text_field",
      value: product.slug,
    },
    product.purchase_url
      ? {
          namespace: "serp",
          key: "purchase_url",
          type: "url",
          value: product.purchase_url,
        }
      : null,
    product.product_page_url
      ? {
          namespace: "serp",
          key: "product_page_url",
          type: "url",
          value: product.product_page_url,
        }
      : null,
    product.ghl
      ? {
          namespace: "serp",
          key: "ghl_config",
          type: "json",
          value: JSON.stringify(product.ghl),
        }
      : null,
    product.stripe
      ? {
          namespace: "serp",
          key: "stripe_config",
          type: "json",
          value: JSON.stringify(product.stripe),
        }
      : null,
    featureItems.length > 0
      ? {
          namespace: "serp",
          key: "feature_list",
          type: "list.single_line_text_field",
          value: JSON.stringify(featureItems),
        }
      : null,
    featuresRich
      ? {
          namespace: "serp",
          key: "features_richtext",
          type: "rich_text_field",
          value: featuresRich,
        }
      : null,
    testimonialItems.length > 0
      ? {
          namespace: "serp",
          key: "testimonials",
          type: "json",
          value: JSON.stringify(testimonialItems),
        }
      : null,
    testimonialsRich
      ? {
          namespace: "serp",
          key: "testimonials_richtext",
          type: "rich_text_field",
          value: testimonialsRich,
        }
      : null,
    faqItems.length > 0
      ? {
          namespace: "serp",
          key: "faqs",
          type: "json",
          value: JSON.stringify(faqItems),
        }
      : null,
    faqsRich
      ? {
          namespace: "serp",
          key: "faq_richtext",
          type: "rich_text_field",
          value: faqsRich,
        }
      : null,
    product.pricing?.label && String(product.pricing.label).trim().length > 0
      ? {
          namespace: "serp",
          key: "pricing_label",
          type: "single_line_text_field",
          value: String(product.pricing.label).trim(),
        }
      : null,
    product.pricing?.note && String(product.pricing.note).trim().length > 0
      ? {
          namespace: "serp",
          key: "pricing_note",
          type: "single_line_text_field",
          value: String(product.pricing.note).trim(),
        }
      : null,
    pricingBenefitsList.length > 0
      ? {
          namespace: "serp",
          key: "pricing_benefits",
          type: "list.single_line_text_field",
          value: JSON.stringify(pricingBenefitsList),
        }
      : null,
    pricingBenefitsRich
      ? {
          namespace: "serp",
          key: "pricing_benefits_richtext",
          type: "rich_text_field",
          value: pricingBenefitsRich,
        }
      : null,
  ].filter(Boolean);

  const tagsString = tags.length > 0 ? tags.join(", ") : undefined;

  const baseProduct = pruneUndefined({
    title,
    body_html: descriptionHtml,
    handle: product.slug,
    status: deriveStatus(product.status),
    product_type: productType,
    tags: tagsString,
    vendor: "SERP Apps",
  });

  const variantPayload = pruneUndefined({
    title: "Default",
    option1: "Default Title",
    price: price ?? "0.00",
    compare_at_price: compareAtPrice ?? undefined,
    sku: product.slug ? String(product.slug).toUpperCase() : undefined,
    requires_shipping: false,
    taxable: false,
    inventory_policy: "deny",
    fulfillment_service: "manual",
  });

  const createPayload = {
    ...baseProduct,
    options: [
      {
        name: "Title",
        values: ["Default Title"],
      },
    ],
    variants: [variantPayload],
  };

  return {
    createPayload,
    updatePayload: baseProduct,
    variantPayload,
    metafields,
    images,
  };
}

async function syncProduct(product) {
  const { createPayload, updatePayload, variantPayload, metafields, images } = mapProductToShopifyPayload(product);
  const existing = await getProductByHandle(product.slug);

  if (!existing) {
    if (!APPLY_MODE) {
      return { slug: product.slug, action: "skipped" };
    }
    const created = await createProductRest(createPayload);
    if (!created) {
      throw new Error("Shopify product create returned no product");
    }

    if (metafields.length > 0) {
      await setProductMetafields(created.admin_graphql_api_id, metafields);
    }

    if (images.length > 0) {
      await replaceProductImages(created.id, images.map((image) => ({ src: image.src ?? image.url ?? image, alt: image.alt })));
    }

    return { slug: product.slug, action: "created" };
  }

  if (!APPLY_MODE) {
    return { slug: product.slug, action: "skipped" };
  }

  const productId = extractNumericId(existing.id);
  if (!productId) {
    throw new Error(`Unable to determine Shopify product ID for ${product.slug}`);
  }

  await updateProductRest(productId, updatePayload);

  const existingVariant = existing.variants?.edges?.[0]?.node;
  if (existingVariant) {
    const variantId = extractNumericId(existingVariant.id);
    if (variantId) {
      await updateVariantRest(variantId, variantPayload);
    }
  }

  if (metafields.length > 0) {
    await setProductMetafields(existing.id, metafields);
  }

  if (images.length > 0) {
    await replaceProductImages(productId, images.map((image) => ({ src: image.src ?? image.url ?? image, alt: image.alt })));
  }

  return { slug: product.slug, action: "updated" };
}

async function syncCollections(products) {
  const categoryMap = new Map();

  for (const product of products) {
    const categories = Array.isArray(product?.shopify_collections)
      ? product.shopify_collections
      : product?.shopify_collections
        ? [product.shopify_collections]
        : product.categories ?? [];
    for (const category of categories) {
      if (!category) continue;
      if (!categoryMap.has(category)) {
        categoryMap.set(category, new Set());
      }
      categoryMap.get(category).add(product.slug);
    }
  }

  for (const [category, slugs] of categoryMap.entries()) {
    const descriptionHtml = `<p>Products tagged with ${category} from the SERP catalog.</p>`;
    await ensureCollection(category, {
      descriptionHtml,
      handle: category.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, ""),
    });
    console.info(`Ensured collection '${category}' with ${slugs.size} products (assignment pending).`);
  }
}

async function main() {
  console.info(
    `Shopify sync targeting store ${getStoreDomain()} (Admin API ${getAdminApiVersion()}) :: mode=${APPLY_MODE ? "apply" : "dry-run"}`,
  );

  const products = readProducts();
  console.info(`Loaded ${products.length} product definitions.`);

  const results = [];
  for (const product of products) {
    try {
      const result = await syncProduct(product);
      results.push(result);
      console.info(`[${result.action}] ${product.slug}`);
    } catch (error) {
      console.error(`Failed to sync product ${product.slug}:`, error);
    }
  }

  if (APPLY_MODE) {
    await syncCollections(products);
  } else {
    console.info("Dry run complete. Re-run with --apply to push changes to Shopify.");
  }

  const summary = results.reduce((acc, result) => {
    acc[result.action] = (acc[result.action] ?? 0) + 1;
    return acc;
  }, {});

  console.info("Summary:", summary);
}

main().catch((error) => {
  console.error("Shopify sync failed:", error);
  process.exitCode = 1;
});
